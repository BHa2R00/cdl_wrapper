(defparameter *subckt* "pmu_core")
(defparameter *ports* (list))
(defun markwd (b)
  (if (pscan "[a-zA-Z0-9,\\_]+[\\<]{1}[0-9]+[\\>]{1}" b)
	(let*((b1 (pscan "[a-zA-Z0-9,\\_]+[\\<]{1}[0-9]+[\\>]{1}" b))
		  (bn (pscan "^[a-zA-Z0-9,\\_]+" b1))
		  (bv (pscan "[\\<]{1}[0-9]+[\\>]{1}" b1))
		  (n (sym+ bn))
		  (v (sym+(preplace "[\\<,\\>]+" bv ""))))
	  (if (not(boundp n)) (set n (list v nil)))
	  ;(format t "markwd ~A = ~A~%" n (eval n))
	  (markwd (preplace (pquote b1) b "")))))
(defun markio (b)
  (if (pscan "[a-zA-Z0-9,\\_]+([\\<]{1}[0-9]+[\\>]{1}){0,1}[:]{1}[I,O,B]{1}" b)
	(let*((b1 (pscan "[a-zA-Z0-9,\\_]+([\\<]{1}[0-9]+[\\>]{1}){0,1}[:]{1}[I,O,B]{1}" b))
		  (bn (pscan "^[a-zA-Z0-9,\\_]+" b1))
		  (n (sym+ bn))
		  (v "inout"))
	  (cond
		((pscan "[:]{1}[I]{1}" b1) (setf v "input"))
		((pscan "[:]{1}[O]{1}" b1) (setf v "output"))
		)
	  (if (boundp n) 
		(set n (list (nth 0 (eval n)) v))
		(set n (list nil v))
		)
	  ;(format t "markio ~A = ~A~%" n (eval n))
	  (markio (preplace (pquote b1) b "")))))
(with-fp-r
  s "../cdl/pmu_core.sp"
  (let ((r nil)
		(line1 ""))
  (do ((line (read-line s nil 'end)
			 (read-line s nil 'end)))
	((equalp line 'end))
	(setf line1 line)
	(if (and
		  (not r)
		  (pscan (string+"^[\\.]{1}SUBCKT\\s+("*subckt*")\\s+") line1)
		  )
	  (let ()
		(setf r t)
		(setf line1 (preplace (string+"^[\\.]{1}SUBCKT\\s+("*subckt*")\\s+") line1 ""))
		)
	  (if (and
			r
			(not(pscan "^[\\+,\\*]{1}" line1))
			)
		(setf r nil)))
	(if (and
		  r
		  (pscan "\\S+" line1)
		  (not(pscan "^[\\*]{1}" line1))
		  )
	  (let ((line2 line1))
		(setf line2 (preplace "[\\+]{1}" line2 ""))
		(markwd line2)
		(setf line2 (preplace "[\\<]{1}[0-9]+[\\>]{1}" line2 ""))
		(let ()
		  )
		;(format t "~S~%" line2)
		(if (pscan "\\S+" line2)
		  (setf *ports* (append *ports* (sym+"("line2")"))))
		))
	(if (and
		  r
		  (pscan "^[\\*]{1}[\\.]{1}PININFO[\\s]+" line1)
		  )
	  (let ()
		(setf line1 (preplace "^[\\*]{1}[\\.]{1}PININFO[\\s]+" line1 ""))
		(markio line1)))
	)))
(setf *ports* (remove-duplicates *ports* :test 'equalp))
(format t "module ~A(~{~A~^, ~});~%" *subckt* *ports*)
(map 'list
	 (lambda (p)
	   (if (and
			 (boundp p)
			 ;(nth 1 (eval p))
			 )
		 (if (numberp (nth 0 (eval p)))
		   (format t "~A	[~A:0]	~A;~%" (nth 1 (eval p)) (nth 0 (eval p)) p)
		   (format t "~A	~A;~%" (nth 1 (eval p)) p)
		   )
		 )
	   )
	 *ports*)
(format t "endmodule~%")
(defparameter *connects* (list))
(map 'list
	 (lambda (p)
	   (if (boundp p)
		 (if (numberp (nth 0 (eval p)))
		   (setf *connects* (append *connects* (list(string+ p"("p"["(nth 0 (eval p))":0])"))));(format t ", .~A(~A[~A:0])" p p (nth 0 (eval p)))
		   (setf *connects* (append *connects* (list(string+ p"("p")"))));(format t ", .~A(~A)" p p)
		   )
		 (setf *connects* (append *connects* (list(string+ p"("p")"))));(format t ", .~A(~A)" p p)
		 )
	   )
	 *ports*)
(format t "~%~{~A~^, ~}~%" *connects*)
